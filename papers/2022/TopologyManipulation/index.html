<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
        
            .title at 0x7f7c2dc316c0&gt; | MIST Lab
        
    </title>
<link href="../../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<link rel="alternate" type="application/rss+xml" title="RSS" href="../../../rss.xml">
<!-- Load modern styles --><link href="../../../assets/css/mist-modern.css" rel="stylesheet">
<!-- Preload header background image for instant rendering --><link rel="preload" as="image" href="../../../images/optimized_milky.jpg">
<meta name="author" content="MIST Lab">
<meta property="og:site_name" content="MIST Lab">
<meta property="og:title" content="Local Topology Manipulation - Supplementary Material">
<meta property="og:url" content="http://mistlab.ca/papers/2022/TopologyManipulation/">
<meta property="og:description" content="Supplementary Material
We provide extra information for the experiments and results in the paper. 

Decentralised rules for robots swarms to form Line and Star

1. Line formation
The line topology is ">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2022-09-26T13:45:07-04:00">
</head>
<body>
    <!-- Enhanced Navigation -->
    <nav class="navbar navbar-default navbar-fixed-top page-scroll" role="navigation" id="main-navbar"><div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a href="../../../"><img src="../../../images/mistlogo.svg" alt="MIST Lab" id="logo" height="50"></a>
            </div>
            
            <div class="collapse navbar-collapse navbar-ex1-collapse page-scroll">
                <ul class="nav navbar-nav navbar-right">
<li><a href="../../../">Home</a></li>
                    <li><a href="../../../about/">About</a></li>
                    <li><a href="../../../about/#people">People</a></li>
                    <li><a href="../../../blog/">Blog</a></li>
                    <li><a href="../../../projects/">Projects</a></li>
                    <li><a href="../../../publications/">Publications</a></li>
                    <li><a href="../../../join/">Join MIST</a></li>
                </ul>
</div>
        </div>
    </nav><!-- Enhanced Page Header --><div class="mist-header-modern">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <h1 class="mist-title-modern">Local Topology Manipulation - Supplementary Material</h1>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Content -->
    <div class="container">
        <div class="row">
            <div class="col-lg-12">
                <div class="mist-content-modern">
                    <h1 id="supplementary-material">Supplementary Material</h1>
<p>We provide extra information for the experiments and results in the paper. </p>
<hr>
<h2 id="decentralised-rules-for-robots-swarms-to-form-line-and-star">Decentralised rules for robots swarms to form Line and Star</h2>
<hr>
<h3 id="1-line-formation">1. Line formation</h3>
<p>The line topology is a special topology, where all the robots have either one neighbor (the ends of the line) and all other robots have two neighbors. The rules that the robots have to follow to form a line are:  </p>
<ul>
<li>
<p>Robots with <strong>degree(robot)&gt;2</strong> to be called Leaf transferer will do a random leaf transfer or super leaf transfer operation. For this they need at least two of their neighbors to be free (i.e., not involved in any other operation). To avoid getting caught in loops the leaf/super leaf remembers the previous leaf transferer and passes this information to the current leaf transferer. The leaf transferer, therefore, doesn't transfer the leaf or super leaf to the previous leaf transferer.</p>
</li>
<li>
<p>Robots with exactly two neighbors try to straighten the angle between their neighbors by moving towards a direction so as to reduce the obtuse angle.  </p>
</li>
</ul>
<p>The parameters used for line formation experiment are $R_{transfer} = 1m$, $R_{mission} = 1.5m$, $R_{range} = 2.5m$. </p>
<hr>
<h3 id="2-star-formation">2. Star formation</h3>
<p>We consider a single root star formation. In star topology, all the robots except the root have one neighbor and the root has $N-1$ neighbors. The rules that the robots have to follow to form a line are:  </p>
<ul>
<li>Each robot connected to the root with more than one neighbor is called a leaflizer, which leaflizes with the root by transferring all its neighbors to the root.  </li>
<li>The root calculates the angles between its leaves and informs them about the direction to make these angles equal.</li>
</ul>
<p>This table shows the parameters used in the star formation experiments.</p>
<hr>
<p>+--------------+-----------------+-------------------+----------------+
| No of robots | $R_{range}$(m)  | $R_{transfer}$(m) |  $R_{Mission}$ |
+--------------+-----------------+-------------------+----------------+
| 15           | 2.5             |  1                |   1.5          |
+--------------+-----------------+-------------------+----------------+
| 30           | 5               |  2                |   3            |
+--------------+-----------------+-------------------+----------------+
| 60           | 10              |  4                |   6            |
+--------------+-----------------+-------------------+----------------+  </p>
<hr>
<h2 id="verification-of-theorem-and-lemma">Verification of Theorem and Lemma</h2>
<h3 id="an-example-for-conversion-from-one-tree-to-another-tree-with-prufer-sequence">An example for conversion from one tree to another tree with Prufer Sequence</h3>
<p>This shows an example as to how to use the prufer sequences and the operations to converrt from any initial tree to final tree. </p>
<p><img src="../../TopologyManipulation/Example-12.png" alt="NSERC" height="1500px" width="900px"></p>
<hr>
<h3 id="test_theoremipynb"><a href="https://git.mistlab.ca/skarthik/local-operations-on-trees/-/blob/main/python-scripts/test_theorem.ipynb">test_theorem.ipynb</a></h3>
<p>In order to verify transformation of trees, we implemented a script in python which verifies the conversion of all possible topologies for a swarm of size 10 to a specific random topology. We also verify that from a random topology it is possible to convert to all other possible topologies. </p>
<div class="code"><pre class="code literal-block"><span class="n">def</span><span class="w"> </span><span class="n">sequence_output</span><span class="p">(</span><span class="n">input_prufer</span><span class="p">,</span><span class="n">final_prufer</span><span class="p">,</span><span class="n">plot</span><span class="o">=</span><span class="k">False</span><span class="p">)</span><span class="err">:</span>

<span class="w">   </span><span class="n">A_input</span><span class="p">,</span><span class="n">input_leaves</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">visualizeP2A</span><span class="p">(</span><span class="n">input_prufer</span><span class="p">,</span><span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">,</span><span class="n">title</span><span class="o">=</span><span class="ss">"Input"</span><span class="p">)</span>
<span class="w">   </span><span class="n">A_final</span><span class="p">,</span><span class="n">final_leaves</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">visualizeP2A</span><span class="p">(</span><span class="n">final_prufer</span><span class="p">,</span><span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">,</span><span class="n">title</span><span class="o">=</span><span class="ss">"Output"</span><span class="p">)</span><span class="w"> </span>

<span class="w">   </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="k">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">input_prufer</span><span class="p">))</span><span class="err">:</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="err">:</span>
<span class="w">         </span><span class="k">if</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="n">is_leaf</span><span class="p">(</span><span class="n">A_input</span><span class="p">,</span><span class="n">final_leaves</span><span class="o">[</span><span class="n">i</span><span class="o">]-</span><span class="mi">1</span><span class="p">)</span><span class="err">:</span><span class="w"> </span><span class="n">#if</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">first</span><span class="w"> </span><span class="n">leaf</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">final</span><span class="w"> </span><span class="n">tree</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">leaf</span><span class="w"> </span>
<span class="w">            </span><span class="n">neighbour</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">A_input</span><span class="o">[</span><span class="n">final_leaves[i</span><span class="o">]-</span><span class="mi">1</span><span class="err">]</span><span class="p">)</span><span class="o">[</span><span class="n">0</span><span class="o">][</span><span class="n">0</span><span class="o">]</span><span class="w">                                                                </span>
<span class="w">            </span><span class="n">#if</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">first</span><span class="w"> </span><span class="n">leaf</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">final</span><span class="w"> </span><span class="n">tree</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">leaf</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">first</span><span class="w"> </span><span class="n">leaf</span><span class="w"> </span><span class="n">leaflize</span><span class="w"> </span><span class="n">it</span><span class="p">.</span>
<span class="w">            </span><span class="n">temp_a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">leaflize</span><span class="p">(</span><span class="n">A_input</span><span class="p">,</span><span class="n">final_leaves</span><span class="o">[</span><span class="n">i</span><span class="o">]-</span><span class="mi">1</span><span class="p">,</span><span class="n">neighbour</span><span class="p">)</span>
<span class="w">            </span><span class="n">title</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">"Leaflize: "</span><span class="o">+</span><span class="nf">str</span><span class="p">(</span><span class="n">final_leaves</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">)</span><span class="o">+</span><span class="ss">" with: "</span><span class="o">+</span><span class="nf">str</span><span class="p">(</span><span class="n">neighbour</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="w">            </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">visualizeA2P</span><span class="p">(</span><span class="n">temp_a</span><span class="p">,</span><span class="n">prufer_flag</span><span class="o">=</span><span class="k">True</span><span class="p">,</span><span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">,</span><span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">)</span>

<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">temp_a</span><span class="o">[</span><span class="n">final_leaves[i</span><span class="o">]-</span><span class="mi">1</span><span class="err">]</span><span class="o">[</span><span class="n">final_prufer[i</span><span class="o">]-</span><span class="mi">1</span><span class="err">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="err">:</span><span class="w"> </span><span class="n">#if</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">created</span><span class="w"> </span><span class="n">leaf</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="n">connected</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">final</span><span class="w"> </span><span class="n">prufer</span><span class="w"> </span><span class="n">do</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">leaf</span><span class="w"> </span><span class="n">transfer</span><span class="p">.</span><span class="w"> </span>
<span class="w">               </span><span class="n">neighbour</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">temp_a</span><span class="o">[</span><span class="n">final_leaves[i</span><span class="o">]-</span><span class="mi">1</span><span class="err">]</span><span class="p">)</span><span class="o">[</span><span class="n">0</span><span class="o">][</span><span class="n">0</span><span class="o">]</span>
<span class="w">               </span><span class="n">temp_a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">leaftransfer</span><span class="p">(</span><span class="n">temp_a</span><span class="p">,</span><span class="n">neighbour</span><span class="p">,</span><span class="n">final_leaves</span><span class="o">[</span><span class="n">i</span><span class="o">]-</span><span class="mi">1</span><span class="p">,</span><span class="n">final_prufer</span><span class="o">[</span><span class="n">i</span><span class="o">]-</span><span class="mi">1</span><span class="p">)</span>
<span class="w">               </span><span class="n">title</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">"Leaftransfer: leaf: "</span><span class="o">+</span><span class="nf">str</span><span class="p">(</span><span class="n">final_leaves</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">)</span><span class="o">+</span><span class="ss">" from: "</span><span class="o">+</span><span class="nf">str</span><span class="p">(</span><span class="n">neighbour</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="ss">" to: "</span><span class="o">+</span><span class="nf">str</span><span class="p">(</span><span class="n">final_prufer</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">)</span>
<span class="w">               </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">visualizeA2P</span><span class="p">(</span><span class="n">temp_a</span><span class="p">,</span><span class="n">prufer_flag</span><span class="o">=</span><span class="k">True</span><span class="p">,</span><span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">,</span><span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">)</span>

<span class="w">         </span><span class="n">elif</span><span class="w"> </span><span class="n">is_leaf</span><span class="p">(</span><span class="n">A_input</span><span class="p">,</span><span class="n">final_leaves</span><span class="o">[</span><span class="n">i</span><span class="o">]-</span><span class="mi">1</span><span class="p">)</span><span class="err">:</span><span class="w"> </span><span class="n">#if</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">leaf</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">A_input</span><span class="o">[</span><span class="n">final_leaves[i</span><span class="o">]-</span><span class="mi">1</span><span class="err">]</span><span class="o">[</span><span class="n">final_prufer[i</span><span class="o">]-</span><span class="mi">1</span><span class="err">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="err">:</span><span class="w"> </span><span class="n">#if</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="n">connected</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">final</span><span class="w"> </span><span class="n">prufer</span><span class="w"> </span><span class="n">do</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">leaf</span><span class="w"> </span><span class="n">transfer</span>
<span class="w">               </span><span class="n">neighbour</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">A_input</span><span class="o">[</span><span class="n">final_leaves[i</span><span class="o">]-</span><span class="mi">1</span><span class="err">]</span><span class="p">)</span><span class="o">[</span><span class="n">0</span><span class="o">][</span><span class="n">0</span><span class="o">]</span>
<span class="w">               </span><span class="n">temp_a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">leaftransfer</span><span class="p">(</span><span class="n">A_input</span><span class="p">,</span><span class="n">neighbour</span><span class="p">,</span><span class="n">final_leaves</span><span class="o">[</span><span class="n">i</span><span class="o">]-</span><span class="mi">1</span><span class="p">,</span><span class="n">final_prufer</span><span class="o">[</span><span class="n">i</span><span class="o">]-</span><span class="mi">1</span><span class="p">)</span>
<span class="w">               </span><span class="n">title</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">"Leaftransfer: leaf: "</span><span class="o">+</span><span class="nf">str</span><span class="p">(</span><span class="n">final_leaves</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">)</span><span class="o">+</span><span class="ss">" from: "</span><span class="o">+</span><span class="nf">str</span><span class="p">(</span><span class="n">neighbour</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="ss">" to: "</span><span class="o">+</span><span class="nf">str</span><span class="p">(</span><span class="n">final_prufer</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">)</span>
<span class="w">               </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">visualizeA2P</span><span class="p">(</span><span class="n">temp_a</span><span class="p">,</span><span class="n">prufer_flag</span><span class="o">=</span><span class="k">True</span><span class="p">,</span><span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">,</span><span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">)</span>


<span class="w">            </span><span class="k">else</span><span class="err">:</span><span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="n">good</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">proceed</span>
<span class="w">               </span><span class="n">temp_a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="n">copy</span><span class="p">(</span><span class="n">A_input</span><span class="p">)</span>

<span class="w">      </span><span class="n">elif</span><span class="w"> </span><span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span><span class="err">:</span>
<span class="w">         </span><span class="k">if</span><span class="w"> </span><span class="n">is_leaf</span><span class="p">(</span><span class="n">temp_a</span><span class="p">,</span><span class="n">final_leaves</span><span class="o">[</span><span class="n">i</span><span class="o">]-</span><span class="mi">1</span><span class="p">)</span><span class="err">:</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">temp_a</span><span class="o">[</span><span class="n">final_leaves[i</span><span class="o">]-</span><span class="mi">1</span><span class="err">]</span><span class="o">[</span><span class="n">final_prufer[i</span><span class="o">]-</span><span class="mi">1</span><span class="err">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="err">:</span><span class="w"> </span><span class="n">#if</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">leaf</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="n">connected</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">final</span><span class="w"> </span><span class="n">prufer</span><span class="w"> </span><span class="n">do</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">leaf</span><span class="w"> </span><span class="n">transfer</span><span class="p">.</span><span class="w"> </span>
<span class="w">               </span><span class="n">neighbour</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">temp_a</span><span class="o">[</span><span class="n">final_leaves[i</span><span class="o">]-</span><span class="mi">1</span><span class="err">]</span><span class="p">)</span><span class="o">[</span><span class="n">0</span><span class="o">][</span><span class="n">0</span><span class="o">]</span>
<span class="w">               </span><span class="n">temp_a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">leaftransfer</span><span class="p">(</span><span class="n">temp_a</span><span class="p">,</span><span class="n">neighbour</span><span class="p">,</span><span class="n">final_leaves</span><span class="o">[</span><span class="n">i</span><span class="o">]-</span><span class="mi">1</span><span class="p">,</span><span class="n">final_prufer</span><span class="o">[</span><span class="n">i</span><span class="o">]-</span><span class="mi">1</span><span class="p">)</span>
<span class="w">               </span><span class="n">title</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">"Leaftransfer: leaf: "</span><span class="o">+</span><span class="nf">str</span><span class="p">(</span><span class="n">final_leaves</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">)</span><span class="o">+</span><span class="ss">" from: "</span><span class="o">+</span><span class="nf">str</span><span class="p">(</span><span class="n">neighbour</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="ss">" to: "</span><span class="o">+</span><span class="nf">str</span><span class="p">(</span><span class="n">final_prufer</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">)</span>
<span class="w">               </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">visualizeA2P</span><span class="p">(</span><span class="n">temp_a</span><span class="p">,</span><span class="n">prufer_flag</span><span class="o">=</span><span class="k">True</span><span class="p">,</span><span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">,</span><span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">)</span>

<span class="w">         </span><span class="n">elif</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="n">is_leaf</span><span class="p">(</span><span class="n">temp_a</span><span class="p">,</span><span class="n">final_leaves</span><span class="o">[</span><span class="n">i</span><span class="o">]-</span><span class="mi">1</span><span class="p">)</span><span class="err">:</span>
<span class="w">            </span><span class="n">all_neighbours</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">temp_a</span><span class="o">[</span><span class="n">final_leaves[i</span><span class="o">]-</span><span class="mi">1</span><span class="err">]</span><span class="p">)</span><span class="o">[</span><span class="n">0</span><span class="o">]</span>
<span class="w">            </span><span class="n">neighbours</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">all_neighbours</span><span class="p">,</span><span class="n">np</span><span class="p">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">final_leaves</span><span class="o">[</span><span class="n">0:i</span><span class="o">]</span><span class="p">,</span><span class="n">np</span><span class="p">.</span><span class="n">ones</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">final_leaves</span><span class="o">[</span><span class="n">0:i</span><span class="o">]</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nc">int</span><span class="p">)))</span>
<span class="w">            </span><span class="n">branches_to_keep</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">all_neighbours</span><span class="p">,</span><span class="n">np</span><span class="p">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">final_leaves</span><span class="o">[</span><span class="n">0:i</span><span class="o">]</span><span class="p">,</span><span class="n">np</span><span class="p">.</span><span class="n">ones</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">final_leaves</span><span class="o">[</span><span class="n">0:i</span><span class="o">]</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nc">int</span><span class="p">)))</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="nf">len</span><span class="p">(</span><span class="n">neighbours</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="err">:</span><span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">subtree</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">leaf</span><span class="w"> </span>
<span class="w">               </span><span class="k">if</span><span class="w"> </span><span class="n">temp_a</span><span class="o">[</span><span class="n">final_leaves[i</span><span class="o">]-</span><span class="mi">1</span><span class="err">]</span><span class="o">[</span><span class="n">final_prufer[i</span><span class="o">]-</span><span class="mi">1</span><span class="err">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="err">:</span><span class="w"> </span><span class="n">#if</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">created</span><span class="w"> </span><span class="n">leaf</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="n">connected</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">final</span><span class="w"> </span><span class="n">prufer</span><span class="w"> </span><span class="n">do</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">leaf</span><span class="w"> </span><span class="n">transfer</span><span class="p">.</span><span class="w"> </span>
<span class="w">                  </span><span class="n">neighbour</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">neighbours</span><span class="o">[</span><span class="n">0</span><span class="o">]</span>
<span class="w">                  </span><span class="n">temp_a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">leaftransfer</span><span class="p">(</span><span class="n">temp_a</span><span class="p">,</span><span class="n">neighbour</span><span class="p">,</span><span class="n">final_leaves</span><span class="o">[</span><span class="n">i</span><span class="o">]-</span><span class="mi">1</span><span class="p">,</span><span class="n">final_prufer</span><span class="o">[</span><span class="n">i</span><span class="o">]-</span><span class="mi">1</span><span class="p">)</span>
<span class="w">                  </span><span class="n">title</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">"Leaftransfer: leaf: "</span><span class="o">+</span><span class="nf">str</span><span class="p">(</span><span class="n">final_leaves</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">)</span><span class="o">+</span><span class="ss">" from: "</span><span class="o">+</span><span class="nf">str</span><span class="p">(</span><span class="n">neighbour</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="ss">" to: "</span><span class="o">+</span><span class="nf">str</span><span class="p">(</span><span class="n">final_prufer</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">)</span>
<span class="w">                  </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">visualizeA2P</span><span class="p">(</span><span class="n">temp_a</span><span class="p">,</span><span class="n">prufer_flag</span><span class="o">=</span><span class="k">True</span><span class="p">,</span><span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">,</span><span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">)</span>

<span class="w">            </span><span class="n">elif</span><span class="w"> </span><span class="nf">len</span><span class="p">(</span><span class="n">neighbours</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="err">:</span><span class="w"> </span><span class="n">#leaflize</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">superleaf</span>
<span class="w">               </span><span class="n">temp_a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">leaflize</span><span class="p">(</span><span class="n">temp_a</span><span class="p">,</span><span class="n">final_leaves</span><span class="o">[</span><span class="n">i</span><span class="o">]-</span><span class="mi">1</span><span class="p">,</span><span class="n">neighbours</span><span class="o">[</span><span class="n">0</span><span class="o">]</span><span class="p">,</span><span class="n">branches_to_keep</span><span class="p">)</span>
<span class="w">               </span><span class="n">title</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">"Leaflize: "</span><span class="o">+</span><span class="nf">str</span><span class="p">(</span><span class="n">final_leaves</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">)</span><span class="o">+</span><span class="ss">" with: "</span><span class="o">+</span><span class="nf">str</span><span class="p">(</span><span class="n">neighbours</span><span class="o">[</span><span class="n">0</span><span class="o">]+</span><span class="mi">1</span><span class="p">)</span>
<span class="w">               </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">visualizeA2P</span><span class="p">(</span><span class="n">temp_a</span><span class="p">,</span><span class="n">prufer_flag</span><span class="o">=</span><span class="k">True</span><span class="p">,</span><span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">,</span><span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">)</span>

<span class="w">               </span><span class="k">if</span><span class="w"> </span><span class="n">temp_a</span><span class="o">[</span><span class="n">final_leaves[i</span><span class="o">]-</span><span class="mi">1</span><span class="err">]</span><span class="o">[</span><span class="n">final_prufer[i</span><span class="o">]-</span><span class="mi">1</span><span class="err">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="err">:</span><span class="w"> </span><span class="n">#if</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">created</span><span class="w"> </span><span class="n">leaf</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="n">connected</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">final</span><span class="w"> </span><span class="n">prufer</span><span class="w"> </span><span class="n">do</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">leaf</span><span class="w"> </span><span class="n">transfer</span><span class="p">.</span><span class="w"> </span>
<span class="w">                  </span><span class="n">neighbour</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">neighbours</span><span class="o">[</span><span class="n">0</span><span class="o">]</span>
<span class="w">                  </span><span class="n">temp_a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">leaftransfer</span><span class="p">(</span><span class="n">temp_a</span><span class="p">,</span><span class="n">neighbour</span><span class="p">,</span><span class="n">final_leaves</span><span class="o">[</span><span class="n">i</span><span class="o">]-</span><span class="mi">1</span><span class="p">,</span><span class="n">final_prufer</span><span class="o">[</span><span class="n">i</span><span class="o">]-</span><span class="mi">1</span><span class="p">)</span>
<span class="w">                  </span><span class="n">title</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">"Leaftransfer: leaf: "</span><span class="o">+</span><span class="nf">str</span><span class="p">(</span><span class="n">final_leaves</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">)</span><span class="o">+</span><span class="ss">" from: "</span><span class="o">+</span><span class="nf">str</span><span class="p">(</span><span class="n">neighbour</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="ss">" to: "</span><span class="o">+</span><span class="nf">str</span><span class="p">(</span><span class="n">final_prufer</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">)</span>
<span class="w">                  </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">visualizeA2P</span><span class="p">(</span><span class="n">temp_a</span><span class="p">,</span><span class="n">prufer_flag</span><span class="o">=</span><span class="k">True</span><span class="p">,</span><span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">,</span><span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">)</span>

<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nf">len</span><span class="p">(</span><span class="n">input_prufer</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="err">:</span>
<span class="w">         </span><span class="n">P</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">visualizeA2P</span><span class="p">(</span><span class="n">temp_a</span><span class="p">,</span><span class="n">prufer_flag</span><span class="o">=</span><span class="k">True</span><span class="p">,</span><span class="n">plot</span><span class="o">=</span><span class="k">False</span><span class="p">)</span>
<span class="w">         </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">P</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">final_prufer</span><span class="p">)</span><span class="err">:</span>
<span class="w">            </span><span class="k">print</span><span class="p">(</span><span class="ss">"input_prufer: "</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nf">str</span><span class="p">(</span><span class="n">input_prufer</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="ss">" final_prufer: "</span><span class="o">+</span><span class="w"> </span><span class="nf">str</span><span class="p">(</span><span class="n">final_prufer</span><span class="p">)</span><span class="o">+</span><span class="ss">" success: "</span><span class="o">+</span><span class="ss">"True"</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="k">True</span>
<span class="w">         </span><span class="k">else</span><span class="err">:</span><span class="w"> </span>
<span class="w">            </span><span class="k">print</span><span class="p">(</span><span class="ss">"input_prufer: "</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nf">str</span><span class="p">(</span><span class="n">input_prufer</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="ss">" final_prufer: "</span><span class="o">+</span><span class="w"> </span><span class="nf">str</span><span class="p">(</span><span class="n">final_prufer</span><span class="p">)</span><span class="o">+</span><span class="ss">" success: "</span><span class="o">+</span><span class="ss">"False"</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="k">False</span>
</pre></div>

<hr>
<h3 id="test_theorem_line_staripynb"><a href="https://git.mistlab.ca/skarthik/local-operations-on-trees/-/blob/main/python-scripts/test_theorem_line_star.ipynb">test_theorem_line_star.ipynb</a></h3>
<p>We also have verified this algorithm in a python script where starting from any random topology we were able to form a star/line for a swarm of size 10 for all the possible $10^8$ combinations. </p>
<div class="code"><pre class="code literal-block"><span class="n">def</span><span class="w"> </span><span class="n">line</span><span class="p">(</span><span class="n">input_prufer</span><span class="p">,</span><span class="n">plot</span><span class="o">=</span><span class="k">False</span><span class="p">)</span><span class="err">:</span>

<span class="w">    </span><span class="n">temp_a</span><span class="p">,</span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">visualizeP2A</span><span class="p">(</span><span class="n">input_prufer</span><span class="p">,</span><span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">,</span><span class="n">title</span><span class="o">=</span><span class="ss">"Input"</span><span class="p">)</span>
<span class="w">    </span><span class="n">num_neighbours</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">temp_a</span><span class="p">,</span><span class="n">np</span><span class="p">.</span><span class="n">ones</span><span class="p">((</span><span class="n">temp_a</span><span class="p">.</span><span class="n">shape</span><span class="o">[</span><span class="n">0</span><span class="o">]</span><span class="p">,</span><span class="mi">1</span><span class="p">))).</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="w">    </span><span class="n">prev_leaf_transfer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="n">ones</span><span class="p">(</span><span class="n">temp_a</span><span class="p">.</span><span class="n">shape</span><span class="o">[</span><span class="n">0</span><span class="o">]</span><span class="p">)</span><span class="o">*-</span><span class="mi">1</span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">num_neighbours</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="err">:</span>
<span class="w">        </span><span class="n">leaf_transferers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">num_neighbours</span><span class="o">&gt;=</span><span class="mi">3</span><span class="p">).</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="w">        </span><span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">leaf_transferers</span><span class="p">)</span>

<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">leaf_transferer</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nl">leaf_transferers</span><span class="p">:</span>
<span class="w">            </span><span class="n">neighbours</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">temp_a</span><span class="o">[</span><span class="n">leaf_transferer</span><span class="o">]==</span><span class="mi">1</span><span class="p">).</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="w">            </span><span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">neighbours</span><span class="p">)</span>
<span class="w">            </span><span class="n">leaf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">neighbours</span><span class="o">[</span><span class="n">0</span><span class="o">]</span>
<span class="w">            </span><span class="n">to_exclude</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="k">array</span><span class="p">(</span><span class="o">[</span><span class="n">leaf,prev_leaf_transfer[leaf</span><span class="o">]</span><span class="err">]</span><span class="p">)</span>
<span class="w">            </span><span class="n">neighbours_to_transfer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">neighbours</span><span class="p">,</span><span class="n">to_exclude</span><span class="p">)</span>
<span class="w">            </span><span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">neighbours_to_transfer</span><span class="p">)</span>
<span class="w">            </span><span class="n">neighbour_to_transfer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">neighbours_to_transfer</span><span class="o">[</span><span class="n">0</span><span class="o">]</span>
<span class="w">            </span><span class="n">prev_leaf_transfer</span><span class="o">[</span><span class="n">leaf</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">leaf_transferer</span><span class="w">  </span>
<span class="w">            </span><span class="n">temp_a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">leaftransfer</span><span class="p">(</span><span class="n">temp_a</span><span class="p">,</span><span class="n">leaf_transferer</span><span class="p">,</span><span class="n">leaf</span><span class="p">,</span><span class="n">neighbour_to_transfer</span><span class="p">)</span>
<span class="w">            </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">visualizeA2P</span><span class="p">(</span><span class="n">temp_a</span><span class="p">,</span><span class="n">prufer_flag</span><span class="o">=</span><span class="k">True</span><span class="p">,</span><span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">,</span><span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">)</span><span class="w">               </span>

<span class="w">        </span><span class="n">num_neighbours</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">temp_a</span><span class="p">,</span><span class="n">np</span><span class="p">.</span><span class="n">ones</span><span class="p">((</span><span class="n">temp_a</span><span class="p">.</span><span class="n">shape</span><span class="o">[</span><span class="n">0</span><span class="o">]</span><span class="p">,</span><span class="mi">1</span><span class="p">))).</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">temp_a</span><span class="p">,</span><span class="n">np</span><span class="p">.</span><span class="n">ones</span><span class="p">((</span><span class="n">temp_a</span><span class="p">.</span><span class="n">shape</span><span class="o">[</span><span class="n">0</span><span class="o">]</span><span class="p">,</span><span class="mi">1</span><span class="p">))).</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>

<div class="code"><pre class="code literal-block"><span class="n">def</span><span class="w"> </span><span class="n">star</span><span class="p">(</span><span class="n">root</span><span class="p">,</span><span class="n">input_prufer</span><span class="p">,</span><span class="n">plot</span><span class="o">=</span><span class="k">False</span><span class="p">)</span><span class="err">:</span>
<span class="w">    </span><span class="n">root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">root</span>
<span class="w">    </span><span class="n">input_prufer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">input_prufer</span>
<span class="w">    </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">len</span><span class="p">(</span><span class="n">input_prufer</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span>
<span class="w">    </span><span class="n">temp_a</span><span class="p">,</span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">visualizeP2A</span><span class="p">(</span><span class="n">input_prufer</span><span class="p">,</span><span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">,</span><span class="n">title</span><span class="o">=</span><span class="ss">"Input"</span><span class="p">)</span>
<span class="w">    </span><span class="n">neighbours_root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">temp_a</span><span class="o">[</span><span class="n">root</span><span class="o">]==</span><span class="mi">1</span><span class="p">).</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="nf">len</span><span class="p">(</span><span class="n">neighbours_root</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="err">:</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">neighbour</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nl">neighbours_root</span><span class="p">:</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="n">is_leaf</span><span class="p">(</span><span class="n">temp_a</span><span class="p">,</span><span class="n">neighbour</span><span class="p">)</span><span class="err">:</span>
<span class="w">                </span><span class="n">title</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">"leaflize: "</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nf">str</span><span class="p">(</span><span class="n">neighbour</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="ss">" with "</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nf">str</span><span class="p">(</span><span class="n">root</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="w">                </span><span class="n">temp_a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">leaflize</span><span class="p">(</span><span class="n">temp_a</span><span class="p">,</span><span class="n">neighbour</span><span class="p">,</span><span class="n">root</span><span class="p">)</span><span class="w">   </span>
<span class="w">                </span><span class="n">visualizeA2P</span><span class="p">(</span><span class="n">temp_a</span><span class="p">,</span><span class="n">prufer_flag</span><span class="o">=</span><span class="k">True</span><span class="p">,</span><span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">,</span><span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">)</span>
<span class="w">        </span><span class="n">neighbours_root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">temp_a</span><span class="o">[</span><span class="n">root</span><span class="o">]==</span><span class="mi">1</span><span class="p">).</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">temp_a</span><span class="p">,</span><span class="n">np</span><span class="p">.</span><span class="n">ones</span><span class="p">((</span><span class="n">temp_a</span><span class="p">.</span><span class="n">shape</span><span class="o">[</span><span class="n">0</span><span class="o">]</span><span class="p">,</span><span class="mi">1</span><span class="p">))).</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>

<hr>
<h2 id="supplementary-plots-for-the-experiments">Supplementary plots for the experiments</h2>
<p><img alt="DARS2022_paper_9102-2-10(1)" src="https://user-images.githubusercontent.com/47322496/190194702-f57e9ee3-b5fd-492a-ba48-8d9bb8b18aff.png"><img alt="DARS2022_paper_9102-2-11(1)" src="https://user-images.githubusercontent.com/47322496/190194705-6338c10d-d549-4aae-845b-ff5c8a79aaa7.png"></p>
<p>Figures 3 and 4 depict $\lambda_2$, coverage area, and progress of operations. We plot the time
evolution of $\lambda_2$ of the graph and the maintained spanning tree, as a connectivity index and a parameter specifying consensus rate. 
The evolution of the number of nodes with $\text{degree(robot)}=1$ (i.e., having only one
neighbor) and $\text{degree(robot)}=2$ is sketched for the line formation and
the evolution of the number of nodes with $\text{degree(robot)}=1$ and nodes
with $\text{degree(robot)}\geq2$ for the star formation, which is a progress
index in each case. The $\lambda_2$ of the manipulated spanning tree and the
whole graph examine the connectivity awareness of our method which has to stay
greater than zero over the experiment. In the specific case of line, $\lambda_2$
of the tree reduces with time and reaches a constant value when the line has
been straightened out. Also, $\lambda_2$ of the graph will approach the same
value, if $R_{\text{mission}}$ is close to $R_{\text{range}}$, which is the minimum for a
given connected graph of $N$ nodes. However, In the case of the star topology,
$\lambda_2$ of the tree increases to a constant value of one at the end of the
experiment no matter the number of nodes in the system, and the $\lambda_2$ of
the graph increases. If $R_{\text{mission}}&lt;R_{\text{range}}/2$ it would have approached an
all to all graph which has the maximum $\lambda_2$ for a given connected graph
of $N$ nodes. The coverage area has been shown to decrease for the star and to
increase for the line case which is showing the trade-off between $\lambda_2$
and the coverage area and that is why topology manipulation is needed to provide
flexibility. Furthermore, for the star formation, we have plotted the number of
nodes with $\text{degree(robot)}=1$ and the number of nodes with
$\text{degree(robot)}\geq2$. This is to show that the manipulation operations
are changing the topology closer to the star topology with time. The number of
nodes with $\text{degree(robot)}=1$ for the star case increases to $N-1$ and
there is exactly one node that has $N-1$ neighbors, which is the root. The plots
show the evolution of these metrics which is increasing for the number of nodes
with $\text{degree(robot)}=1$ and decreasing for the number of nodes with
$\text{degree(robot)}\geq2$. For line formation, we have shown a similar metric
that reduces to 2 for the number of nodes $\text{degree(robot)}=1$ and increases
to $N-2$ for the number of nodes $\text{degree(robot)}=2$ which is the
definition of a line topology.</p>
<h2 id="setting-up-the-simlations-for-line-and-star-in-argos3-and-buzz">Setting up the simlations for Line and Star in Argos3 and Buzz.</h2>
<p>The code for the experiments can be found <a href="https://git.mistlab.ca/skarthik/local-operations-on-trees">here</a>.
ARGoS3 Simulator ARGoS3 simulator can also be installed from binaries please refer to the official website for more information: https://www.argos-sim.info/
The instructions below are for installing ARGoS3 from its source.
Official code repository: https://github.com/ilpincy/argos3
Dependencies for ARGoS3 can be installed using the following command:</p>
<div class="code"><pre class="code literal-block">sudo apt-get install cmake libfreeimage-dev libfreeimageplus-dev \
qt5-default freeglut3-dev libxi-dev libxmu-dev liblua5.3-dev \
lua5.3 doxygen graphviz graphviz-dev asciidoc
</pre></div>

<p>Installations for Argos3 </p>
<div class="code"><pre class="code literal-block">$<span class="w"> </span>git<span class="w"> </span>clone<span class="w"> </span>https://github.com/ilpincy/argos3.git<span class="w"> </span>argos3
$<span class="w"> </span><span class="nb">cd</span><span class="w"> </span>argos3
$<span class="w"> </span>mkdir<span class="w"> </span>build_simulator
$<span class="w"> </span><span class="nb">cd</span><span class="w"> </span>build_simulator
$<span class="w"> </span>cmake<span class="w"> </span>../src
$<span class="w"> </span>make
$<span class="w"> </span>sudo<span class="w"> </span>make<span class="w"> </span>install
</pre></div>

<p>Installations for Buzz</p>
<div class="code"><pre class="code literal-block">$<span class="w"> </span><span class="nb">cd</span><span class="w"> </span>Buzz
$<span class="w"> </span>mkdir<span class="w"> </span>build
$<span class="w"> </span><span class="nb">cd</span><span class="w"> </span>build
$<span class="w"> </span>cmake<span class="w"> </span>../src
$<span class="w"> </span>sudo<span class="w"> </span>make<span class="w"> </span>install
$<span class="w"> </span>sudo<span class="w"> </span>ldconfig
</pre></div>

<p>Installations for Khepera V</p>
<div class="code"><pre class="code literal-block">$<span class="w"> </span>git<span class="w"> </span>clone<span class="w"> </span>https://github.com/ilpincyargos3-kheperaiv.git
$<span class="w"> </span>mkdir<span class="w"> </span>build_sim
$<span class="w"> </span><span class="nb">cd</span><span class="w"> </span>build_sim
$<span class="w"> </span>cmake<span class="w"> </span>-DCMAKE_BUILD_TYPE<span class="o">=</span>Release<span class="w"> </span>../src
$<span class="w"> </span>make
$<span class="w"> </span>sudo<span class="w"> </span>make<span class="w"> </span>install
</pre></div>

<p>Building the loop function for ARGoS:</p>
<div class="code"><pre class="code literal-block">$<span class="w"> </span><span class="nb">cd</span><span class="w"> </span>files/loop_fun_src/
$<span class="w"> </span>mkdir<span class="w"> </span>build
$<span class="w"> </span><span class="nb">cd</span><span class="w"> </span>build/
$<span class="w"> </span>cmake<span class="w"> </span>..
$<span class="w"> </span>make
</pre></div>

<p>Building the buzz script. </p>
<div class="code"><pre class="code literal-block">$<span class="w"> </span><span class="nb">cd</span><span class="w"> </span>buzz_scripts
$<span class="w"> </span>bzzc<span class="w"> </span>leaf_transfer2.bzz/leaflize_15.bzz/leaflize_30.bzz/leaflize_60.bzz
<span class="c1"># for line/star_15/star_30/star_60</span>
</pre></div>

<div class="code"><pre class="code literal-block"><span class="nv">To</span><span class="w"> </span><span class="nv">run</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="nv">Argos3</span><span class="w"> </span><span class="nv">file</span>.<span class="w"> </span>
<span class="nv">argos3</span><span class="w"> </span><span class="o">-</span><span class="nv">c</span><span class="w"> </span><span class="nv">files</span><span class="o">/</span><span class="nv">star</span>.<span class="nv">argos</span><span class="w"> </span>#<span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="mi">15</span><span class="w"> </span><span class="nv">robots</span>
<span class="nv">argos3</span><span class="w"> </span><span class="o">-</span><span class="nv">c</span><span class="w"> </span><span class="nv">files</span><span class="o">/</span><span class="nv">line</span>.<span class="nv">argos</span><span class="w"> </span>#<span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="mi">15</span><span class="w"> </span><span class="nv">robots</span>
</pre></div>

<hr>
<h2 id="video-for-60-robots-line-and-star-formation">Video for 60 robots (line and star formation)</h2>
<p><iframe width="1100" height="500" src="https://www.youtube.com/embed/QNoxGxlbseE" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></p>
<hr>
</div>
                
                    <section class="comments-section"><h3>Comments</h3>
                        
    
<div id="fb-root"></div>
<script>
  window.fbAsyncInit = function() {
    // init the FB JS SDK
    FB.init({
      appId      : '',
      status     : true,
      xfbml      : true
    });

  };

  // Load the SDK asynchronously
  (function(d, s, id){
     var js, fjs = d.getElementsByTagName(s)[0];
     if (d.getElementById(id)) {return;}
     js = d.createElement(s); js.id = id;
     js.src = "https://connect.facebook.net/en_US/all.js";
     fjs.parentNode.insertBefore(js, fjs);
   }(document, 'script', 'facebook-jssdk'));
</script><div class="fb-comments" data-href="http://mistlab.ca/papers/2022/TopologyManipulation/" data-width="470"></div>


                    </section>
</div>
        </div>
    </div>


    <!-- Enhanced Footer -->
    <footer class="footer-modern"><div class="container">
            <div class="row">
                <div class="col-lg-9">
                    Contents  2025 <a href="mailto:info@mistlab.ca">MIST Lab</a> - 
                    Powered by <a href="http://getnikola.com" rel="nofollow">Nikola</a>
                </div>
                <div class="col-lg-3">
                    <ul class="list-unstyled list-inline list-social-icons">
<li>Follow us:</li>
                        <li class="tooltip-social facebook-link">
                            <a href="https://www.facebook.com/mistlab.ca" data-toggle="tooltip" data-placement="top" title="Facebook">
                                <i class="fa fa-facebook-square fa-2x"></i>
                            </a>
                        </li>
                        <li class="tooltip-social twitter-link">
                            <a href="https://twitter.com/MIST_lab" data-toggle="tooltip" data-placement="top" title="Twitter">
                                <i class="fa fa-twitter-square fa-2x"></i>
                            </a>
                        </li>
                        <li class="tooltip-social google-plus-link">
                            <a href="https://google.com/+MistlabCa" data-toggle="tooltip" data-placement="top" title="Google+">
                                <i class="fa fa-google-plus-square fa-2x"></i>
                            </a>
                        </li>
                    </ul>
</div>
            </div>
        </div>
    </footer><!-- JavaScript Dependencies --><script src="https://code.jquery.com/jquery-3.6.0.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js"></script><!-- MIST Lab Modern Theme JavaScript --><script src="../../../assets/js/mist-modern.js"></script><!-- Enhanced JavaScript --><script>
        document.addEventListener('DOMContentLoaded', function() {
            // Enhanced navbar scroll effect
            window.addEventListener('scroll', function() {
                const navbar = document.getElementById('main-navbar');
                if (navbar) {
                    if (window.scrollY > 50) {
                        navbar.classList.add('navbar-scrolled');
                    } else {
                        navbar.classList.remove('navbar-scrolled');
                    }
                }
            });

            // Set active navbar item based on current page
            const basePath = '/mistlab.github.io';
            let currentPath = window.location.pathname;
            if (currentPath.startsWith(basePath)) {
                currentPath = currentPath.slice(basePath.length) || '/';
            }
            const navLinks = document.querySelectorAll('.navbar-nav a');
            
            function updateActiveNavigation() {
                const currentHash = window.location.hash; // Get current hash each time
                
                navLinks.forEach(link => {
                    const linkUrl = new URL(link.href);
                    let linkPath = linkUrl.pathname;
                    const linkHash = linkUrl.hash;
                    if (linkPath.startsWith(basePath)) {
                        linkPath = linkPath.slice(basePath.length) || '/';
                    }
                    // Remove active class from all items
                    link.parentElement.classList.remove('active');
                    
                    // Handle About page with People section
                    if (currentPath === '/about/') {
                        if (linkPath === '/about/' && linkHash === '#people') {
                            // Check if we're in people section by scroll position or hash
                            const peopleElement = document.getElementById('people');
                            if (peopleElement) {
                                const scrollPosition = window.scrollY + 100; // offset for navbar
                                const peoplePosition = peopleElement.getBoundingClientRect().top + window.scrollY;
                                
                                if (currentHash === '#people' || scrollPosition >= peoplePosition) {
                                    // Highlight People when at #people section or scrolled past it
                                    link.parentElement.classList.add('active');
                                    return;
                                }
                            }
                        } else if (linkPath === '/about/' && !linkHash) {
                            // Only highlight About if we haven't reached people section yet
                            const peopleElement = document.getElementById('people');
                            if (peopleElement) {
                                const scrollPosition = window.scrollY + 100;
                                const peoplePosition = peopleElement.getBoundingClientRect().top + window.scrollY;
                                
                                if (!currentHash && scrollPosition < peoplePosition) {
                                    link.parentElement.classList.add('active');
                                }
                            } else if (!currentHash) {
                                // Fallback if people element not found
                                link.parentElement.classList.add('active');
                            }
                        }
                        return;
                    }
                    
                    // Regular page matching (exact match for home, contains for others)
                    if (currentPath === linkPath || 
                        (currentPath.includes(linkPath) && linkPath !== '/') ||
                        (currentPath === '/' && linkPath === '/')) {
                        link.parentElement.classList.add('active');
                    }
                });
            }
            
            // Initial call
            updateActiveNavigation();
            
            // Update on scroll for about page
            if (currentPath === '/about/') {
                window.addEventListener('scroll', function() {
                    updateActiveNavigation();
                }, { passive: true });
            }
            
            // Handle hash changes for single-page navigation
            window.addEventListener('hashchange', function() {
                // Update current hash and re-run navigation logic
                window.location.hash; // trigger update
                updateActiveNavigation();
            });

            // Smooth scrolling for anchor links
            document.querySelectorAll('a[href^="#"]').forEach(anchor => {
                anchor.addEventListener('click', function (e) {
                    e.preventDefault();
                    const target = document.querySelector(this.getAttribute('href'));
                    if (target) {
                        target.scrollIntoView({
                            behavior: 'smooth',
                            block: 'start'
                        });
                    }
                });
            });

            // Initialize tooltips only
            if (typeof $ !== 'undefined' && $.fn.tooltip) {
                $('[data-toggle="tooltip"]').tooltip();
            }

            // Add fade-in animation to cards when they come into view
            if ('IntersectionObserver' in window) {
                const observerOptions = {
                    threshold: 0.1,
                    rootMargin: '0px 0px -50px 0px'
                };

                const observer = new IntersectionObserver(function(entries) {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            entry.target.classList.add('animate-fadeInUp');
                        }
                    });
                }, observerOptions);

                // Observe all cards
                document.querySelectorAll('.modern-card, .feature-card').forEach(card => {
                    observer.observe(card);
                });
            }
        });
    </script><script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-40192557-1', 'mistlab.ca');
  ga('send', 'pageview');

</script>
</body>
</html>
